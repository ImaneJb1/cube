## **1. File Validation**   ✅ 

Before touching any parsing logic:

1. **Check file extension** ✅

2. **Check file can be opened** ✅

3. **Ensure the file is not empty** 

   * If `read()` returns `0` before reading anything → error.

## **2. Read the File** 

* Read the file **line by line** using `get_next_line`.✅
* Store lines in a temporary linked list or dynamic array (so you can scan multiple times if needed).

---

## **3. Identify and Parse the Configuration Section** ✅

The configuration part is **always before the map** in `.cub` files.
You must extract **exactly 6 required elements** before starting the map:

1. **Texture paths** (strings, not empty):✅

   * `NO path/to/north_texture.xpm`
   * `SO path/to/south_texture.xpm`
   * `WE path/to/west_texture.xpm`
   * `EA path/to/east_texture.xpm`
   * For **bonus**:

     * `FLOOR` / `CEILING` textures (optional if colors are used)
     * Sprite textures (`S`, or multiple IDs like `DOOR`, `ITEM`, etc.).
2. **Floor color (F)** and **Ceiling color (C)**:

   * Format: `R,G,B` (0–255 each).
   * No extra commas, no spaces between numbers unless trimmed.
   * Bonus can allow textures for floor/ceiling instead of RGB.

**Rules to follow:**

* Skip empty lines in config section, but **not inside the map**.
* Each identifier must appear **exactly once** (or error).
* Paths must be to valid `.xpm` files (check access with `open()`).

---

## **4. Transition Point Detection**

After you successfully parse the 6 required elements:

* The **first non-empty line after configs** is the start of the map.
* From here, you cannot have:

  * Empty lines inside the map.
  * Random config lines after the map starts.

---

## **5. Map Extraction**

* Store the map lines into a **2D char array** or dynamic array.
* Keep track of:

  * Map width (max line length).
  * Map height (number of lines).

---

## **6. Map Validation**

This is where most people lose points. You need to check:

### **A. Allowed characters**

* `0` → empty space
* `1` → wall
* `N`, `S`, `E`, `W` → player spawn (only **one** allowed)
* Bonus: `D` (door), `2` (sprite), etc.
* Spaces inside the map must be treated as “out of bounds” (not walkable).

### **B. Player spawn**

* Exactly **one** player spawn.
* Store:

  * Position (center of the cell: `x + 0.5`, `y + 0.5`)
  * Direction (vector from N/S/E/W)

### **C. Closed map check**

* The map must be completely enclosed by walls (`1`) or out-of-bounds.
* No “holes” to the void.
* **Algorithm**:

  * Pad the map with walls/spaces to make all rows same length.
  * BFS/DFS from player position or all `0`s — if you can reach the “outside” → error.

---

## **7. Extra Bonus Parsing**

For bonus features like doors, animated sprites, minimap:

* Store door positions in a separate array/list for the game loop.
* Keep sprite coordinates in a sprite list with type ID.
* If using multiple textures per object (animation frames), store them as arrays of `mlx_xpm_file_to_image`.

---

## **8. Cleanup & Struct Filling**

Once parsing is done and validated:

* Free temporary storage (like raw file lines).
* Fill your `t_data` or `t_game` struct with:

  * Texture pointers.
  * Map 2D array.
  * Player pos & dir.
  * Color values or floor/ceiling textures.
  * Sprite list / door list.

---

## **9. Common Error Cases to Handle**

* Missing or duplicated identifiers.
* Invalid RGB values (`>255` or `<0`).
* Path file doesn’t exist or not `.xpm`.
* Empty map.
* Map not surrounded by walls.
* Multiple player spawns.
* Spaces touching `0` without wall barrier.
